"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionAPIClient = exports.SESSION_SERVICE_URL = void 0;
exports.listRunning = listRunning;
exports.getSessionUrl = getSessionUrl;
exports.shutdownSession = shutdownSession;
exports.getSessionModel = getSessionModel;
exports.startSession = startSession;
exports.updateSession = updateSession;
const serverconnection_1 = require("../serverconnection");
const coreutils_1 = require("@jupyterlab/coreutils");
const validate_1 = require("./validate");
/**
 * The url for the session service.
 */
exports.SESSION_SERVICE_URL = 'api/sessions';
/**
 * List the running sessions.
 */
async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.SESSION_SERVICE_URL);
    const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
    if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
    }
    const data = await response.json();
    if (!Array.isArray(data)) {
        throw new Error('Invalid Session list');
    }
    data.forEach(m => {
        (0, validate_1.updateLegacySessionModel)(m);
        (0, validate_1.validateModel)(m);
    });
    return data;
}
/**
 * Get a session url.
 */
function getSessionUrl(baseUrl, id) {
    const servicesBase = coreutils_1.URLExt.join(baseUrl, exports.SESSION_SERVICE_URL);
    const result = coreutils_1.URLExt.join(servicesBase, id);
    if (!result.startsWith(servicesBase)) {
        throw new Error('Can only be used for services requests');
    }
    return result;
}
/**
 * Shut down a session by id.
 */
async function shutdownSession(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
    var _a;
    const url = getSessionUrl(settings.baseUrl, id);
    const init = { method: 'DELETE' };
    const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
    if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The session "${id}"" does not exist on the server`;
        console.warn(msg);
    }
    else if (response.status === 410) {
        throw new serverconnection_1.ServerConnection.ResponseError(response, 'The kernel was deleted but the session was not');
    }
    else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
    }
}
/**
 * Get a full session model from the server by session id string.
 */
async function getSessionModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = getSessionUrl(settings.baseUrl, id);
    const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
    if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
    }
    const data = await response.json();
    (0, validate_1.updateLegacySessionModel)(data);
    (0, validate_1.validateModel)(data);
    return data;
}
/**
 * Create a new session, or return an existing session if the session path
 * already exists.
 */
async function startSession(options, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.SESSION_SERVICE_URL);
    const init = {
        method: 'POST',
        body: JSON.stringify(options)
    };
    const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
    if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
    }
    const data = await response.json();
    (0, validate_1.updateLegacySessionModel)(data);
    (0, validate_1.validateModel)(data);
    return data;
}
/**
 * Send a PATCH to the server, updating the session path or the kernel.
 */
async function updateSession(model, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = getSessionUrl(settings.baseUrl, model.id);
    const init = {
        method: 'PATCH',
        body: JSON.stringify(model)
    };
    const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
    if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
    }
    const data = await response.json();
    (0, validate_1.updateLegacySessionModel)(data);
    (0, validate_1.validateModel)(data);
    return data;
}
/**
 * The session API client.
 *
 * #### Notes
 * Use this class to interact with the Jupyter Server Session API.
 * This class adheres to the Jupyter Server API endpoints.
 */
class SessionAPIClient {
    /**
     * Create a new session API client.
     *
     * @param options - The options used to create the client.
     */
    constructor(options) {
        var _a;
        this.serverSettings =
            (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
    }
    /**
     * List the running sessions.
     *
     * @returns A promise that resolves with the list of running session models.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions) and validates the response model.
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    async listRunning() {
        return listRunning(this.serverSettings);
    }
    /**
     * Get a session model.
     *
     * @param id - The id of the session of interest.
     *
     * @returns A promise that resolves with the session model.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions) and validates the response model.
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    async getModel(id) {
        return getSessionModel(id, this.serverSettings);
    }
    /**
     * Create a new session.
     *
     * @param options - The options used to create the session.
     *
     * @returns A promise that resolves with the session model.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions) and validates the response model.
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    async startNew(options) {
        return startSession(options, this.serverSettings);
    }
    /**
     * Shut down a session by id.
     *
     * @param id - The id of the session to shut down.
     *
     * @returns A promise that resolves when the session is shut down.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions) and validates the response model.
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    async shutdown(id) {
        return shutdownSession(id, this.serverSettings);
    }
    /**
     * Update a session by id.
     *
     * @param model - The session model to update.
     *
     * @returns A promise that resolves with the updated session model.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions) and validates the response model.
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    async update(model) {
        return updateSession(model, this.serverSettings);
    }
}
exports.SessionAPIClient = SessionAPIClient;
//# sourceMappingURL=restapi.js.map