[
  {
    "subject": "ml",
    "level": "level2",
    "status": "passed",
    "timestamp": "2025-08-21T11:31:12.029219",
    "answers": [
      {
        "questionId": "house_prices_full_task_v1_data_inspection",
        "code": "import pandas as pd\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\ntrain_data=pd.read_csv('/home/bit/Desktop/ps/ml2/backend/data/datasets/house-prices/train.csv')\r\nmissing_values=train_data.isnull().sum()\r\nmissing_values=missing_values[missing_values>0]\r\nfor col,count in missing_values.items():\r\n    print(f\"{col} {count}\")",
        "passed": true,
        "fully_passed": true
      },
      {
        "questionId": "house_prices_full_task_v1_model_training",
        "code": "#!/usr/bin/env python3\r\nimport os\r\nimport sys\r\nimport traceback\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom sklearn.linear_model import LinearRegression\r\nfrom sklearn.model_selection import train_test_split\r\nfrom sklearn.metrics import mean_squared_error, r2_score\r\n\r\n# ---- edit this if your train file is elsewhere ----\r\ntrain_candidates = [\r\n    \"/home/bit/Desktop/ps/ml2/backend/data/datasets/house-prices/train.csv\",\r\n    \"/mnt/data/Housing.csv\",\r\n    \"/mnt/data/train.csv\",\r\n    \"./train.csv\",\r\n    \"train.csv\"\r\n]\r\n\r\ndef find_existing_path(candidates):\r\n    for p in candidates:\r\n        if os.path.exists(p):\r\n            return p\r\n    return None\r\n\r\ntrain_path = find_existing_path(train_candidates)\r\nif train_path is None:\r\n    print(\"ERROR: training file not found. Tried these paths:\")\r\n    for p in train_candidates:\r\n        print(\"  \", p)\r\n    sys.exit(1)\r\n\r\nprint(\"Using training file:\", train_path)\r\n\r\n# Load dataset (try latin1 fallback on failure)\r\ntry:\r\n    df = pd.read_csv(train_path)\r\nexcept Exception:\r\n    try:\r\n        df = pd.read_csv(train_path, encoding=\"latin1\")\r\n        print(\"Loaded with encoding='latin1'\")\r\n    except Exception:\r\n        print(\"Failed to read CSV. Traceback:\")\r\n        traceback.print_exc()\r\n        sys.exit(1)\r\n\r\n# Quick inspect (optional)\r\nprint(\"\\nColumns found in the training file:\")\r\nprint(list(df.columns))\r\nprint(\"\\nFirst 3 rows of the dataset:\")\r\nprint(df.head(3))\r\n\r\n# Detect target\r\npossible_targets = [\"SalePrice\", \"saleprice\"]\r\ntarget_col = next((c for c in possible_targets if c in df.columns), None)\r\nif target_col is None:\r\n    print(\"ERROR: Could not find target column 'SalePrice' in the dataset.\")\r\n    sys.exit(1)\r\n\r\nprint(\"\\nTarget column detected:\", target_col)\r\n\r\n# Prepare feature matrix X and target y\r\n# Drop Id (if present) and the target column\r\ndrop_cols = [target_col]\r\nif \"Id\" in df.columns:\r\n    drop_cols.append(\"Id\")\r\n\r\nX = df.drop(columns=drop_cols)\r\n# Keep only numeric columns to keep preprocessing simple (you can extend later)\r\nX = X.select_dtypes(include=[np.number]).copy()\r\ny = df[target_col].copy()\r\n\r\nif X.shape[1] == 0:\r\n    print(\"ERROR: No numeric features available after selection. Add preprocessing for categorical columns.\")\r\n    sys.exit(1)\r\n\r\n# Fill numeric missing values with median (no chained assignment)\r\nX = X.fillna(X.median())\r\n\r\n# Optionally print how many missing values remain (should be zero for numeric)\r\nremaining_missing = X.isnull().sum().sum()\r\nprint(f\"\\nRemaining missing values in numeric features: {remaining_missing}\")\r\n\r\n# Train/test split\r\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)\r\n\r\n# Train Linear Regression\r\nmodel = LinearRegression()\r\nmodel.fit(X_train, y_train)\r\n\r\n# Predict on hold-out set\r\ny_pred = model.predict(X_test)\r\n\r\n# Evaluate\r\nmse = mean_squared_error(y_test, y_pred)   # mean squared error\r\nrmse = np.sqrt(mse)                        # root mean squared error (explicit sqrt)\r\nr2 = r2_score(y_test, y_pred)\r\n\r\n# Print outputs in the required format\r\nprint(f\"\\nRoot Mean Squared Error: {rmse}\")\r\nprint(f\"R-squared: {r2}\")\r\n",
        "passed": true,
        "fully_passed": true
      },
      {
        "questionId": "house_prices_full_task_v1_prediction",
        "code": "import os\r\nimport sys\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom sklearn.linear_model import LinearRegression\r\nfrom sklearn.model_selection import train_test_split\r\nfrom sklearn.metrics import mean_squared_error, r2_score\r\n\r\n# ---------- Adjust these if your files are elsewhere ----------\r\ntrain_candidates = [\r\n    \"/home/bit/Desktop/ps/ml2/backend/data/datasets/house-prices/train.csv\",\r\n    \"/mnt/data/Housing.csv\",\r\n    \"/mnt/data/train.csv\",\r\n    \"./train.csv\",\r\n]\r\ntest_candidates = [\r\n    \"/home/bit/Desktop/ps/ml2/backend/data/datasets/house-prices/test.csv\",\r\n    \"/mnt/data/Housing (1).csv\",\r\n    \"/mnt/data/test.csv\",\r\n    \"./test.csv\",\r\n]\r\n# ---------- end paths -----------------------------------------\r\n\r\ndef find_any_file(cands):\r\n    for p in cands:\r\n        if os.path.exists(p):\r\n            return p\r\n    return None\r\n\r\ntrain_path = find_any_file(train_candidates)\r\ntest_path = find_any_file(test_candidates)\r\n\r\nif train_path is None or test_path is None:\r\n    print(\"ERROR: Could not find train and/or test files.\")\r\n    print(\"Tried these train paths:\", *train_candidates, sep=\"\\n  \")\r\n    print(\"Tried these test  paths:\", *test_candidates, sep=\"\\n  \")\r\n    print(\"\\nIf your files are in a different location, set train_candidates/test_candidates accordingly.\")\r\n    raise SystemExit(1)\r\n\r\nprint(\"Using train file:\", train_path)\r\nprint(\"Using test  file:\", test_path)\r\n\r\n# ----------------- Load data -----------------\r\ntrain_df = pd.read_csv(train_path)\r\ntest_df = pd.read_csv(test_path)\r\n\r\n# Detect target column (SalePrice or price or similar)\r\ntarget_col = None\r\nfor c in train_df.columns:\r\n    lc = c.strip().lower().replace(\" \", \"\")\r\n    if lc == \"saleprice\" or lc == \"price\":\r\n        target_col = c\r\n        break\r\n\r\nif target_col is None:\r\n    print(\"Could not detect target column in training data. Columns are:\")\r\n    print(list(train_df.columns))\r\n    raise SystemExit(1)\r\n\r\nprint(\"Detected target column:\", target_col)\r\n\r\n# ----------------- Prepare features -----------------\r\n# drop ID from train features if present\r\ntrain_features = train_df.drop(columns=[target_col], errors=\"ignore\")\r\nif \"Id\" in train_features.columns:\r\n    train_features = train_features.drop(columns=[\"Id\"])\r\n\r\n# Prepare test features and keep Id\r\nif \"Id\" in test_df.columns:\r\n    test_ids = test_df[\"Id\"].copy()\r\n    test_features = test_df.drop(columns=[\"Id\"])\r\nelse:\r\n    test_ids = pd.Series(np.arange(1, len(test_df) + 1), name=\"Id\")\r\n    test_features = test_df.copy()\r\n    print(\"Warning: Test file has no 'Id' column \u2014 generating 1..N ids for submission.\")\r\n\r\n# If test accidentally contains target column, drop it\r\ntest_features = test_features.drop(columns=[target_col], errors=\"ignore\")\r\n\r\n# Reset index so y lines up later\r\ny = train_df[target_col].reset_index(drop=True)\r\ntrain_features = train_features.reset_index(drop=True)\r\ntest_features = test_features.reset_index(drop=True)\r\n\r\n# Combine for consistent one-hot encoding\r\ncombined = pd.concat([train_features, test_features], axis=0, ignore_index=True)\r\n\r\n# ----------------- Missing value imputation (safe assignments) -----------------\r\n# numeric median\r\nnum_cols = combined.select_dtypes(include=[np.number]).columns\r\nfor col in num_cols:\r\n    med = combined[col].median()\r\n    # safe assignment (avoids chained assignment warnings)\r\n    combined.loc[:, col] = combined.loc[:, col].fillna(med)\r\n\r\n# categorical: fill with mode or \"Missing\"\r\ncat_cols = combined.select_dtypes(include=[\"object\", \"category\"]).columns\r\nfor col in cat_cols:\r\n    mode_vals = combined.loc[:, col].mode()\r\n    if not mode_vals.empty:\r\n        mode_val = mode_vals[0]\r\n    else:\r\n        mode_val = \"Missing\"\r\n    combined.loc[:, col] = combined.loc[:, col].fillna(mode_val)\r\n\r\n# ----------------- Encoding -----------------\r\ncombined_encoded = pd.get_dummies(combined, drop_first=True)\r\n\r\n# Split back\r\nn_train = len(train_features)\r\nX_all = combined_encoded.iloc[:n_train, :].reset_index(drop=True)\r\nX_test = combined_encoded.iloc[n_train:, :].reset_index(drop=True)\r\n\r\n# Sanity check\r\nif X_all.shape[0] != len(y):\r\n    raise RuntimeError(\"Internal error: train rows mismatch after encoding.\")\r\n\r\nprint(\"Feature matrix shape (train):\", X_all.shape)\r\nprint(\"Feature matrix shape (test) :\", X_test.shape)\r\n\r\n# ----------------- Train/Validation split -----------------\r\nX_train, X_val, y_train, y_val = train_test_split(\r\n    X_all, y, test_size=0.20, random_state=42\r\n)\r\n\r\n# ----------------- Model training -----------------\r\nmodel = LinearRegression()\r\nmodel.fit(X_train, y_train)\r\n\r\n# ----------------- Evaluation -----------------\r\ny_val_pred = model.predict(X_val)\r\nrmse = np.sqrt(mean_squared_error(y_val, y_val_pred))\r\nr2 = r2_score(y_val, y_val_pred)\r\n\r\n# EXACT expected print format\r\nprint(f\"Root Mean Squared Error: {rmse}\")\r\nprint(f\"R-squared: {r2}\")\r\n\r\n# ----------------- Part 3: Predictions & submission.csv -----------------\r\n# Ensure test feature columns match model input (they should, because we concatenated)\r\nif X_test.shape[1] != X_all.shape[1]:\r\n    # sanity fallback: reindex to match train columns\r\n    X_test = X_test.reindex(columns=X_all.columns, fill_value=0)\r\n\r\ntest_preds = model.predict(X_test)\r\n\r\nsubmission = pd.DataFrame({\r\n    \"Id\": test_ids,\r\n    \"SalePrice\": test_preds\r\n})\r\n\r\nsubmission.to_csv(\"submission.csv\", index=False)\r\nprint(\"Saved submission.csv (Id,SalePrice) \u2014 first 5 rows:\")\r\nprint(submission.head())\r\n",
        "passed": true,
        "fully_passed": true
      }
    ]
  }
]